// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: cities.sql

package database

import (
	"context"
)

const activeCities = `-- name: ActiveCities :many
SELECT id, name_en, name_ar, is_active
FROM cities
WHERE is_active = TRUE
ORDER BY id
LIMIT $1 OFFSET $2
`

type ActiveCitiesParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ActiveCities(ctx context.Context, arg ActiveCitiesParams) ([]City, error) {
	rows, err := q.db.Query(ctx, activeCities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []City
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.ID,
			&i.NameEn,
			&i.NameAr,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const activeCitiesCount = `-- name: ActiveCitiesCount :one
SELECT COUNT(*)
FROM cities
WHERE is_active = TRUE
`

func (q *Queries) ActiveCitiesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, activeCitiesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const allCities = `-- name: AllCities :many
SELECT id, name_en, name_ar, is_active
FROM cities
ORDER BY id
LIMIT $1 OFFSET $2
`

type AllCitiesParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) AllCities(ctx context.Context, arg AllCitiesParams) ([]City, error) {
	rows, err := q.db.Query(ctx, allCities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []City
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.ID,
			&i.NameEn,
			&i.NameAr,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const citiesCount = `-- name: CitiesCount :one
SELECT COUNT(*)
FROM cities
`

func (q *Queries) CitiesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, citiesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCity = `-- name: CreateCity :one
INSERT INTO cities(name_en, name_ar, is_active)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateCityParams struct {
	NameEn   string
	NameAr   string
	IsActive bool
}

func (q *Queries) CreateCity(ctx context.Context, arg CreateCityParams) (int64, error) {
	row := q.db.QueryRow(ctx, createCity, arg.NameEn, arg.NameAr, arg.IsActive)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteCity = `-- name: DeleteCity :exec
DELETE
FROM cities
WHERE id = $1
`

func (q *Queries) DeleteCity(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCity, id)
	return err
}

const filterCities = `-- name: FilterCities :many
SELECT id, name_en, name_ar, is_active
FROM cities
WHERE name_en ILIKE $3 or name_ar ILIKE $3
ORDER BY id
LIMIT $1 OFFSET $2
`

type FilterCitiesParams struct {
	Limit  int64
	Offset int64
	Query  string
}

func (q *Queries) FilterCities(ctx context.Context, arg FilterCitiesParams) ([]City, error) {
	rows, err := q.db.Query(ctx, filterCities, arg.Limit, arg.Offset, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []City
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.ID,
			&i.NameEn,
			&i.NameAr,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCity = `-- name: UpdateCity :one
UPDATE cities
SET name_en=$1,
    name_ar=$2,
    is_active=$3
WHERE id = $4
RETURNING id, name_en, name_ar, is_active
`

type UpdateCityParams struct {
	NameEn   string
	NameAr   string
	IsActive bool
	ID       int64
}

func (q *Queries) UpdateCity(ctx context.Context, arg UpdateCityParams) (City, error) {
	row := q.db.QueryRow(ctx, updateCity,
		arg.NameEn,
		arg.NameAr,
		arg.IsActive,
		arg.ID,
	)
	var i City
	err := row.Scan(
		&i.ID,
		&i.NameEn,
		&i.NameAr,
		&i.IsActive,
	)
	return i, err
}
